# -*- coding: utf-8 -*-
"""
/***************************************************************************
 documentosDialog
                                 A QGIS plugin
 plugin para apresentar timeline dos documentos
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2022-02-22
        git sha              : $Format:%H$
        copyright            : (C) 2022 by Jhonatan
        email                : jhonatan.goncalves@hotmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os


from PyQt5.QtCore import QFileInfo, QSize
from PyQt5.QtGui import QPixmap
import xlrd
from .error_dialog import ErrorDialog

from qgis.PyQt.QtGui import QFont, QBrush, QColor, QPainter, QPen
from qgis.PyQt import QtWidgets
from qgis.PyQt.uic import loadUiType
from qgis.PyQt.QtCore import pyqtSignal, Qt, QMargins, QRect

from qgis.core import QgsProject, QgsFeatureRequest, QgsApplication, QgsCategorizedSymbolRenderer, QgsMessageLog


class FileButton(QtWidgets.QPushButton):
	def __init__(self, path):
		self.path = path
		super(FileButton, self).__init__()
		#self.setFixedWidth(10)
		self.clicked.connect(lambda: self.open_document())

	def open_document(self):
		os.startfile(self.path)

class ImageButton(QtWidgets.QAbstractButton):
	def __init__(self, pixmap, parent=None):
		super(ImageButton, self).__init__(parent)
		self.pixmap = pixmap

	def paintEvent(self, event):
		painter = QPainter(self)
		painter.drawPixmap(event.rect(), self.pixmap)

	def sizeHint(self):
		return self.pixmap.size()

class Document(object):
	def __init__(self, path, title):
		self.path = path
		self.title = title
		super(Document, self).__init__()
		

# This loads your .ui file so that PyQt can populate your plugin with the elements from Qt Designer
FORM_CLASS, _ = loadUiType(os.path.join(
    os.path.dirname(__file__), 'documents_dialog_base.ui'))

class documentosDialog(QtWidgets.QDialog, FORM_CLASS):

	book = xlrd.open_workbook(QgsApplication.qgisSettingsDirPath()+"python\\plugins\\documents\\timeline - documentos.xls")
	sheet = book.sheet_by_name("timeline")
	months_labels = ["Jan","Fev","Mar","Abr","Mai","Jun","Jul","Ago","Set","Out","Nov","Dez"]


	def __init__(self, id, parent=None):
		"""Constructor."""
		super(documentosDialog, self).__init__(parent)
		# Set up the user interface from Designer.
		# After setupUI you can access any designer object by doing
		# self.<objectname>, and you can use autoconnect slots - see
		# http://qt-project.owrg/doc/qt-4.8/designer-using-a-ui-file.html
		# #widgets-and-dialogs-with-auto-connect
		QgsMessageLog.logMessage("const","plugin")
		self.docs = {}
		self.id = id
		self.currentYear = 0
		self.prevButton = ImageButton(QPixmap(QgsApplication.qgisSettingsDirPath()+"python\\plugins\\documents\\prev.png"))
		self.nextButton = ImageButton(QPixmap(QgsApplication.qgisSettingsDirPath()+"python\\plugins\\documents\\next.png"))
		self.prevButton.setFixedWidth(53)
		self.nextButton.setFixedWidth(53)
		self.prevButton.clicked.connect(self.prev_year)
		self.nextButton.clicked.connect(self.next_year)
		self.prevEventButton = ImageButton(QPixmap(QgsApplication.qgisSettingsDirPath()+"python\\plugins\\documents\\prev.png"))
		self.nextEventButton = ImageButton(QPixmap(QgsApplication.qgisSettingsDirPath()+"python\\plugins\\documents\\next.png"))
		self.prevEventButton.setFixedWidth(53)
		self.nextEventButton.setFixedWidth(53)
		self.prevEventButton.clicked.connect(self.prev_year)
		self.nextEventButton.clicked.connect(self.next_year)
		self.setupUi(self)
		self.populate_treeview()
		self.create_timeline()
		self.listWidget.itemChanged.connect(self.update_timeline)

	def populate_treeview(self):
		
		filters = self.sheet.col(3)
		filters = list(set(filters))
		ids = self.sheet.col(0)
		ids = list(set(ids))
		cells =[]
		
		for value, id in zip(filters, ids):
			if (value.value not in cells) and (value.value != "DETALHAMENTO") and id.value == self.id:
				cells.append(value.value)

		for cell in cells:
			item = QtWidgets.QListWidgetItem(cell, self.listWidget)
			item.setFlags(item.flags() or Qt.ItemIsUserCheckable)
			item.setCheckState(Qt.Checked)
		
	def create_timeline(self):
		i = 0
		for row in self.sheet.get_rows():
			if row[2].value != "DATA" and row[0].value == self.id:
				year, month, d, h, mn, s = xlrd.xldate_as_tuple(row[2].value, self.book.datemode)
				if d >=0 and d <11:
					section = 0
				elif d>=11 and d < 21:
					section = 1
				elif d > 21:
					section = 2
				if year not in self.docs.keys():
					self.docs[year] = {}
				if month not in self.docs[year].keys():
					self.docs[year][month] = {}
				if section not in self.docs[year][month].keys():
					self.docs[year][month][section] = {}
				if row[3].value not in self.docs[year][month][section].keys():
					self.docs[year][month][section][row[3].value] = []
				self.docs[year][month][section][row[3].value].append(Document(row[7].value,row[1].value))
		self.docs = dict(sorted(self.docs.items()))
		if self.docs:
			docs_timeline = QtWidgets.QWidget()
			docs_timeline.setLayout(QtWidgets.QHBoxLayout())
			docs_timeline.layout().addWidget(self.prevButton)
			docs_timeline.layout().addWidget(self.create_year(False))
			docs_timeline.layout().addWidget(self.nextButton)
   
			events_timeline = QtWidgets.QWidget()
			events_timeline.setLayout(QtWidgets.QHBoxLayout())
			events_timeline.layout().addWidget(self.prevEventButton)
			events_timeline.layout().addWidget(self.create_year(True))
			events_timeline.layout().addWidget(self.nextEventButton)

			self.scrollAreaDocs.setWidget(docs_timeline)
			self.scrollAreaEvents.setWidget(events_timeline)

	def create_year(self, events):
		yearNumber = list(self.docs.keys())[self.currentYear]
		year = QtWidgets.QWidget()
		year.setLayout(QtWidgets.QVBoxLayout())
		year.layout().setSpacing(0)  # No Spacing
		year.layout().setContentsMargins(0, 0, 0, 0)

		line = QtWidgets.QWidget()
		line.setLayout(QtWidgets.QHBoxLayout())
		line.layout().setSpacing(0)  # No Spacing
		line.layout().setContentsMargins(0, 0, 0, 0)
		
		for monthNumber in range(12):
			month = self.create_month(monthNumber, yearNumber, events)
			line.layout().addWidget(month)
   		
		label = QtWidgets.QLabel(str(yearNumber))
		label.setFont(QFont("Otahoma",10,QFont.Bold))
		label.setAlignment(Qt.AlignCenter)
		
		year.layout().addWidget(line,Qt.AlignCenter)
		year.layout().addWidget(label)

		return year

	def create_month(self, monthNumber, yearNumber, events):
		docButtons = []
		for i in range(0,3):
			if events:
				docButtons.append(self.create_events(monthNumber+1, i,yearNumber))
			else:
				docButtons.append(self.create_buttons(monthNumber+1, i,yearNumber))
    			
					
		month = QtWidgets.QWidget()
		month.setLayout(QtWidgets.QVBoxLayout())
		month.layout().setSpacing(0)  # No Spacing
		month.layout().setContentsMargins(0, 0, 0, 0)
		month.layout().addStretch(1)

		rect = 	QtWidgets.QFrame()
		rect.autoFillBackground()
		rect.setFixedHeight(10)
		rect.setAttribute(Qt.WA_StyledBackground, True)
		rect.setStyleSheet('background-color: red;')

		seps = QtWidgets.QWidget()
		seps.setLayout(QtWidgets.QHBoxLayout())
		seps.layout().setSpacing(0)  # No Spacing
		seps.layout().setContentsMargins(0, 0, 0, 0)


		sep1 = QtWidgets.QWidget()
		sep1.setLayout(QtWidgets.QVBoxLayout())
		sep1.layout().setSpacing(0)  # No Spacing
		sep1.layout().setContentsMargins(0, 0, 0, 0)
		sep1.layout().addStretch(1)
		
		l = QtWidgets.QLabel(self.months_labels[monthNumber])

		sep1_tick = QtWidgets.QFrame()
		sep1_tick.setFixedWidth(1)
		sep1_tick.setFixedHeight(10)
		sep1_tick.setAttribute(Qt.WA_StyledBackground, True)
		sep1_tick.setStyleSheet('background-color: red;')
		
		sep1.layout().addWidget(l, alignment=Qt.AlignLeft)
		sep1.layout().addWidget(sep1_tick, alignment=Qt.AlignLeft)

		seps.layout().addWidget(sep1, alignment=Qt.AlignLeft)
		
		for docButton in docButtons:
			if docButton != None:
				sep2 = QtWidgets.QWidget()

				sep2.setLayout(QtWidgets.QVBoxLayout())
				sep2.layout().setSpacing(0)  # No Spacing
				sep2.layout().setContentsMargins(0, 0, 0, 0)
				sep2.layout().addStretch(1)


				sep2_tick = QtWidgets.QFrame()
				sep2_tick.setFixedWidth(2)
				sep2_tick.setFixedHeight(50)
				sep2_tick.setAttribute(Qt.WA_StyledBackground, True)
				sep2_tick.setStyleSheet('background-color: black;')
				
				sep2.layout().addWidget(docButton, alignment=Qt.AlignHCenter)
				sep2.layout().addWidget(sep2_tick, alignment=Qt.AlignHCenter)

				seps.layout().addWidget(sep2, alignment=Qt.AlignHCenter)


		month.layout().addWidget(seps)
		month.layout().addWidget(rect)
		return month


	def create_buttons(self, month, section, year):
		docButton = QtWidgets.QWidget()
		#docButton.setFixedWidth(10)
		docButton.setLayout(QtWidgets.QVBoxLayout())
		docButton.layout().setSpacing(0)  # No Spacing
		docButton.layout().setContentsMargins(0, 0, 0, 0)
		docButton.layout().addStretch(1)
		hasButton = False
		if month in self.docs[year].keys():
			if section in self.docs[year][month].keys():
				for i in range(self.listWidget.count()):
					docBlock = self.listWidget.item(i)
					if docBlock.checkState() and docBlock.text() in self.docs[year][month][section].keys():
						for doc in self.docs[year][month][section][docBlock.text()]:
							path = doc.path
							fileInfo = QFileInfo(path)
							iconProvider =QtWidgets.QFileIconProvider()
							icon = iconProvider.icon(fileInfo)
							button = FileButton(path)
							button.setIcon(icon)
							button.setToolTip(doc.title)
							docButton.layout().addWidget(button, alignment=Qt.AlignHCenter)
							hasButton = True
				if hasButton:
					return docButton
		return None

	def create_events(self, month, section, year):
		docButton = QtWidgets.QWidget()
		#docButton.setFixedWidth(10)
		docButton.setLayout(QtWidgets.QVBoxLayout())
		docButton.layout().setSpacing(0)  # No Spacing
		docButton.layout().setContentsMargins(0, 0, 0, 0)
		docButton.layout().addStretch(1)
		hasButton = False
		if month in self.docs[year].keys():
			if section in self.docs[year][month].keys():
				for i in range(self.listWidget.count()):
					docBlock = self.listWidget.item(i)
					if docBlock.checkState() and docBlock.text() in self.docs[year][month][section].keys():
						for doc in self.docs[year][month][section][docBlock.text()]:
							button = QtWidgets.QPushButton()
							button.setFixedWidth(30)
							button.setEnabled(False)
							button.setToolTip(doc.title)
							docButton.layout().addWidget(button, alignment=Qt.AlignHCenter)
							hasButton = True
				if hasButton:
					return docButton
		return None
	
	def next_year(self):
		self.currentYear += 1
		self.update_timeline()
		if self.currentYear == len(self.docs.keys())-1:
			self.nextButton.setEnabled(False)
			self.nextEventButton.setEnabled(False)
		elif self.currentYear == 1:
			self.prevButton.setEnabled(True)
			self.prevEventButton.setEnabled(True)

	def prev_year(self):
		if self.currentYear == 0:
			return
		self.currentYear -= 1
		self.update_timeline()
		if self.currentYear == len(self.docs.keys())-2:
			self.nextButton.setEnabled(True)
			self.nextEventButton.setEnabled(True)
		elif self.currentYear <= 0:
			self.prevButton.setEnabled(False)
			self.prevEventButton.setEnabled(False)

	def update_timeline(self):
		self.update_docs()
		self.update_events()
 
	def update_docs(self):
		w = self.scrollAreaDocs.takeWidget()
		w.layout().itemAt(1).widget().hide()
		w.layout().replaceWidget(w.layout().itemAt(1).widget(),self.create_year(False))
		self.scrollAreaDocs.setWidget(w)
		self.scrollAreaDocs.verticalScrollBar().setValue(
			self.scrollAreaDocs.verticalScrollBar().maximum())
	
	def update_events(self):
		w = self.scrollAreaEvents.takeWidget()
		w.layout().itemAt(1).widget().hide()
		w.layout().replaceWidget(w.layout().itemAt(1).widget(),self.create_year(True))
		self.scrollAreaEvents.setWidget(w)
		self.scrollAreaEvents.verticalScrollBar().setValue(
			self.scrollAreaEvents.verticalScrollBar().maximum())
